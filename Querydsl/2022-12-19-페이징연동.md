### 페이징 연동
---

이제 querydsl로 페이징을 해보자.

참고로 현재 사용중인 querydsl 5.0.0에서는 count 쿼리를 직접 날리도록 권장하고 있기 때문에

조회 쿼리와 count 쿼리를 분리해서 작성하는 것이 좋다.

```Java
@Override
public Page<MemberTeamDto> searchPage(MemberSearchCond cond, Pageable pageable) {

    List<MemberTeamDto> content = queryFactory
            .select(Projections.constructor(
                    MemberTeamDto.class,
                    member.id,
                    member.username,
                    member.age,
                    team.id,
                    team.name
            ))
            .from(member)
            .join(member.team, team)
            .where(
                    usernameEq(cond.getUsername()),
                    teamNameEq(cond.getTeamName()),
                    ageGoe(cond.getAgeGoe()),
                    ageLoe(cond.getAgeLoe())
            )
            .offset(pageable.getOffset())
            .limit(pageable.getPageSize())
            .fetch();

    Long total = queryFactory
            .select(member.count())
            .from(member)
            .where(
                    usernameEq(cond.getUsername()),
                    teamNameEq(cond.getTeamName()),
                    ageGoe(cond.getAgeGoe()),
                    ageLoe(cond.getAgeLoe())
            )
            .fetchOne();

    return new PageImpl<>(content, pageable, total);
}
```

<br>

### 테스트 코드
---

```Java
@Test
public void searchPageTest() {

    MemberSearchCond cond = new MemberSearchCond();
    PageRequest pageRequest = PageRequest.of(1, 2);

    Page<MemberTeamDto> memberTeamDtos = memberRepository.searchPage(cond, pageRequest);
    
    assertThat(memberTeamDtos.getContent())
            .extracting("username")
            .containsExactly("member3", "member4");

    assertThat(memberTeamDtos.getTotalElements()).isEqualTo(4);
}
```

잘 동작한다 굿

<br>

### 개선하기
---

count 쿼리가 항상 필요할까?

마지막 페이지의 경우 size + offset을 하면 전체 size를 구할 수 있고,

시작 페이지이면서 컨텐츠 사이즈가 페이지 사이즈보다 작을 때 count 쿼리가 필요 없음을 알 수 있다.

따라서 count 쿼리가 필요할 때만 쿼리를 날리는 PageableExecutionUtils.getPage()로 최적화할 수 있다.

```Java
@Override
public Page<MemberTeamDto> searchPage(MemberSearchCond cond, Pageable pageable) {

    List<MemberTeamDto> content = queryFactory
            .select(Projections.constructor(
                    MemberTeamDto.class,
                    member.id,
                    member.username,
                    member.age,
                    team.id,
                    team.name
            ))
            .from(member)
            .join(member.team, team)
            .where(
                    usernameEq(cond.getUsername()),
                    teamNameEq(cond.getTeamName()),
                    ageGoe(cond.getAgeGoe()),
                    ageLoe(cond.getAgeLoe())
            )
            .offset(pageable.getOffset())
            .limit(pageable.getPageSize())
            .fetch();

    JPAQuery<Long> countQuery = queryFactory
            .select(member.count())
            .from(member)
            .where(
                    usernameEq(cond.getUsername()),
                    teamNameEq(cond.getTeamName()),
                    ageGoe(cond.getAgeGoe()),
                    ageLoe(cond.getAgeLoe())
            );

    return PageableExecutionUtils.getPage(content, pageable, countQuery::fetchOne);
}
```

<br>

### 테스트 코드
---

```Java
@Test
public void searchPageTest() {

    MemberSearchCond cond = new MemberSearchCond();
    PageRequest pageRequest = PageRequest.of(0, 10);

    Page<MemberTeamDto> memberTeamDtos = memberRepository.searchPage(cond, pageRequest);
    
    assertThat(memberTeamDtos.getContent())
            .extracting("username")
            .containsExactly("member1", "member2", "member3", "member4");

    assertThat(memberTeamDtos.getTotalElements()).isEqualTo(4);
}

// 발생한 쿼리를 살펴보면 count 쿼리가 나가지 않음을 알 수 있다. 첫 페이지를 요청했고, content의 사이즈가 요청 pageSize 보다 작기 때문이다.
```